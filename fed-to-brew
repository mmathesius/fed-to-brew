#!/bin/bash
###############
# GET USER SETABLE VARIABLES
###############
SCRIPT_HOME="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
if [ -f ${SCRIPT_HOME}/fed-to-brew.conf ] ; then
  source ${SCRIPT_HOME}/fed-to-brew.conf
elif [ -f /etc/fed-to-brew.conf ] ; then
  source /etc/fed-to-brew.conf
else
  echo "Unable to find fed-to-brew.conf"
  echo "Expecting it to be ${SCRIPT_HOME}/fed-to-brew.conf or /etc/fed-to-brew.conf"
  echo "Exiting ..."
  exit 42
fi

###############
# OTHER SCRIPT VARIABLES
###############
VERBOSE="FALSE"
REMOTE="TRUE"
BREW_CHECK="TRUE"
LOGFILE="${WORKDIR}/logs/output-$(date +%Y-%m-%d)"
LOCK_FILE="${WORKDIR}/logs/lockfile-$(date +%Y-%m-%d)"
WEB_DIR="${WORKDIR}/results/"
OVERALL_TXT="${WEB_DIR}/overall-status.txt"
OVERALL_HTML="${WEB_DIR}/overall-status.html"
BUILDING_HTML="${WEB_DIR}/overall-building-status.html"
FAILURE_HTML="${WEB_DIR}/overall-failure-status.html"
MODULE_LIST="BootSelf Bootstrap Hardware Host Installer Perl Platform"
JOB_TRACKER="${WORKDIR}/job-tracker-$$"
PARALLEL_JOBS=4
DEP_LIST="brew git fedpkg koji rhpkg flock"
COMMAND=""
PACKAGE_LIST=""
CUSTOM_MESSAGE=""
YAML_FILE=""
TEXT_FILE=""

###############
# SETUP and CHECK
###############
mkdir -vp ${WORKDIR}/{brew,fed,logs,map,results,tmp}
touch ${LOCK_FILE}
for this_dep in ${DEP_LIST}
do
  test_path="$(which ${this_dep} 2>/dev/null)"
  if [ "${test_path}" == "" ] ; then
    echo "${this_dep} was not found in your path."
    echo "${DEP_LIST} needs to be installed, and in your path."
    echo "exiting..."
    exit 1
  fi
done

###############
# Show help
###############
usage() {
  echo "Usage `basename $0` [command] <options> <[package 1] ... [package n]>" >&2
  echo >&2
  echo "Multipurpose tool to help tracking, syncing, building packages between" >&2
  echo "  fedora and brew." >&2
  echo >&2
  echo "Commands: (there must be one command, only one)" >&2
  echo "  --sync" >&2
  echo "    Sync package(s) from Fedora dist-git to Brew dist-git." >&2
  echo "    Only syncs from one git commit, does not do entire history." >&2
  echo "    Mandatory: --brew-branch" >&2
  echo "    Mandatory: --yaml OR --text OR [package]" >&2
  echo "  --check" >&2
  echo "    Check the status of builds" >&2
  echo "  --build --rebuild" >&2
  echo "    Build package(s) in brew, if they have not already been built." >&2
  echo "    Will sync packages Fedora dist-git to Brew dist-git if needed." >&2
  echo "    Mandatory: --brew-branch" >&2
  echo "    Mandatory: --brew-dist" >&2
  echo "    Mandatory: --yaml OR --text OR [package]" >&2
  echo >&2
  echo "Options:" >&2
  echo "  -c --checkout [branch or hash]" >&2
  echo "    What to checkout of the fedora dist-git, can be branch or hash" >&2
  echo "    Warning: If using hash, only use one package" >&2
  echo "    Default: ${FED_GIT_CHECKOUT}" >&2
  echo "    Example branch: f26" >&2
  echo "    Example hash: 082464dc0d06d48d2f9c4d2110e8aafe4ef1c957" >&2
  echo "  -bb --brew-branch [branch]" >&2
  echo "    What brew branch to sync to" >&2
  echo "  -fd --fed-dist [dist]" >&2
  echo "    What to dist to pull the fedora source from" >&2
  echo "    Should only be needed if using a hash for checkout" >&2
  echo "    Default: ${FED_DIST}" >&2
  echo "    Example: f26" >&2
  echo "  -bd --brew-dist [dist]" >&2
  echo "    What dist tag to use when checking brew build status" >&2
  echo "    Example: .el7" >&2
  echo "  -m --message [message]" >&2
  echo "    Use a custom commit message for brew dist-git" >&2
  echo "  --text [file]" >&2
  echo "    Text file to use for list of packages" >&2
  echo "      Each package is on its own line in format <n-v-r>.src" >&2
  echo "      Example:acl-2.2.52-15.fc27.src" >&2
  echo "  --yaml [file]" >&2
  echo "    yaml file to use for list of packages" >&2
  echo "      Should be in the standard fedora module yaml file format." >&2
  echo "  --jobs [Integer]" >&2
  echo "    Number of jobs to do in parallel" >&2
  echo "  --no-remote --noremote" >&2
  echo "    Do not sync map ore results remotely.  Default: ${REMOTE} " >&2
  echo "  -v --verbose --debug" >&2
  echo "    Be verbose, for debugging" >&2
  echo "  --brew-check --brewcheck" >&2
  echo "    Check if we have a brew dist-git branch before doing work" >&2
  echo "  -h, --help" >&2
  echo "    Show this options menu" >&2
  echo >&2
  echo "Other:" >&2
  echo "  [package]" >&2
  echo "    If you want to do just a single file, list just the name" >&2
  echo "    Not applied if either --yaml or --text are used." >&2
  echo >&2
  popd &>/dev/null
  exit 1
}

###############
# Parse a yaml file
###############
function parse_yaml {
   local prefix=$2
   local s='[[:space:]]*' w='[a-zA-Z0-9_-+.]*' fs=$(echo @|tr @ '\034')
   sed -ne "s|^\($s\):|\1|" \
        -e "s|^\($s\)\($w\)$s:$s[\"']\(.*\)[\"']$s\$|\1$fs\2$fs\3|p" \
        -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p"  $1 |
   awk -F$fs '{
      indent = length($1)/2;
      vname[indent] = $2;
      for (i in vname) {if (i > indent) {delete vname[i]}}
      if (length($3) > 0) {
         vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
         printf("%s%s%s=\"%s\"\n", "'$prefix'",vn, $2, $3);
      }
   }'
}

###############
# Return the list of packages
###############
function get_packages {
  if [ "${YAML_FILE}" != "" ] ; then
    for line in $(parse_yaml ${YAML_FILE})
    do
      if echo $line | grep -q _ref= ; then
        this_name="$(echo $line | awk -F'__' '{print $4}')"
        fed_hash="$(echo $line | awk -F'"' '{print $2}')"
        echo "${this_name} ${fed_hash}"
      fi
    done
  elif [ "${TEXT_FILE}" != "" ] ; then
    for line in $(cat "${TEXT_FILE}")
    do
      fed_nvr="$(echo ${line} | sed "s/-[0-9]*:/-/" | sed 's/.src$//')"
      fed_hash="$(fedpkg gitbuildhash ${fed_nvr} 2>/dev/null)"
      this_name="$(koji rpminfo ${fed_nvr}.src | grep 'SRPM Path:' | awk -F'/' '{print $5}')"
      echo "${this_name} ${fed_hash} ${fed_nvr}"
    done
  elif [ "${PACKAGE_LIST}" != "" ] ; then
    for this_name in ${PACKAGE_LIST}
    do
      cd ${WORKDIR}/tmp
      fedpkg clone ${this_name} >> ${LOGFILE} 2>&1
      cd ${this_name}
      git checkout ${FED_GIT_CHECKOUT} >> ${LOGFILE} 2>&1
      fed_hash="$(git log -n1 --format=%H)"
      cd ${WORKDIR}/tmp
      rm -rf ${WORKDIR}/tmp/${this_name}
      echo "${this_name} ${fed_hash}"
    done
  else
    echo ; echo "ERROR: No packages or files given to process" ; echo
    usage
    exit 5
  fi
}

###############
# Update overall status in results directory
###############
update_overall_status() {
  update_name="${1}"
  update_status="${2}"
  update_task_number="${3}"
  update_nvr="${4}"
  if [ "${VERBOSE}" == "TRUE" ] ; then
      echo "    update_name: ${update_name}"
      echo "    update_nvr: ${update_nvr}"
      echo "    update_task_number: ${update_task_number}"
      echo "    update_status: ${update_status}"
    fi
    if grep -q "^${update_name} " ${OVERALL_TXT} ; then
      flock ${LOCK_FILE} sed -i "s|^${update_name} .*|${update_name} ${update_status} ${update_nvr} ${BREW_WEB_URL}/taskinfo?taskID=${update_task_number}|" ${OVERALL_TXT}
    else
      flock ${LOCK_FILE} echo "${update_name} ${update_status} ${update_nvr} ${BREW_WEB_URL}/taskinfo?taskID=${update_task_number}" >> ${OVERALL_TXT}
    fi
}

###############
# rsync directory out to remote server
###############
rsync_out() {
  this_dir="${1}"
  if [ "${VERBOSE}" == "TRUE" ] ; then
    echo "    this_dir: ${this_dir}"
    echo "    SYNC_REMOTE: ${SYNC_REMOTE}"
  fi
  if [ "${this_dir}" != "" ] && [ -d ${WORKDIR}/${this_dir} ] ; then
    rsync -avH --exclude=.git/ --delete ${WORKDIR}/${this_dir}/ ${SYNC_REMOTE}/${this_dir}/
  else
    echo "  ERROR: We cannot rsync ${WORKDIR}/${this_dir} remotely"
  fi
}

###############
# rsync directory in from remote server
###############
rsync_in() {
  this_dir="${1}"
  if [ "${VERBOSE}" == "TRUE" ] ; then
    echo "    this_dir: ${this_dir}"
    echo "    SYNC_REMOTE: ${SYNC_REMOTE}"
  fi
  if [ "${this_dir}" != "" ] ; then
    rsync -avH --exclude=.git/ --delete ${SYNC_REMOTE}/${this_dir}/ ${WORKDIR}/${this_dir}/
  else
    echo "  ERROR: No directory was passed to rsync into"
  fi
}

###############
# Sync fedora dist-git to brew dist-git
###############
sync_distgit() {
  job_type="${1}"
  job_number="${2}"
  this_name="$(echo ${3} | awk '{print $1}')"
  fed_hash="$(echo ${3} | awk '{print $2}')"
  if [ "${fed_hash}" == "" ] ; then
    fed_hash="${FED_GIT_CHECKOUT}"
  fi
  echo "    [${this_name}] Syncing dist-git start"
  # Checkout Fedora dist-git
  echo "      [${this_name}] Download and Setup Fedora dist-git repo"
  cd ${WORKDIR}/fed
  if [ -d ${this_name} ] ; then
    rm -rf ${this_name}
  fi
  fedpkg clone ${this_name} >> ${LOGFILE} 2>&1
  if ! [ $? -eq 0 ] ; then
    echo "      [${this_name}] Unable to clone"
    echo "        [${this_name}] You might not have permissions, or might not be a package."
    end_job ${job_number}
    exit 1
  fi
  cd ${this_name}
  git checkout ${fed_hash} >> ${LOGFILE} 2>&1
  if ! [ $? -eq 0 ] ; then
    echo "      [${this_name}] Unable to checkout ${this_name} ${fed_hash}"
    end_job ${job_number}
    exit 1
  fi
  fedpkg sources >> ${LOGFILE} 2>&1
  if ! [ $? -eq 0 ] ; then
    # For hashtags we have to pass a dist, assuming rawhide
    fedpkg --dist ${FED_DIST} sources >> ${LOGFILE} 2>&1
    if ! [ $? -eq 0 ] ; then
      echo "      [${this_name}] Error: We are unable to get our sources for ${this_name}"
      end_job ${job_number}
      exit 1
    fi
  fi
  if [ "${CUSTOM_MESSAGE}" == "" ] ; then
    COMMIT_MESSAGE="$(git log -n1 --format=%s)"
  else
    COMMIT_MESSAGE="${CUSTOM_MESSAGE}"
  fi
  THIS_NVR="$(fedpkg --release master verrel 2>/dev/null | sed 's|.fc2[0-9]|.dist|')"
  if [ "${THIS_NVR}" == "" ] ; then
    THIS_NVR="${this_name}"
  fi
  FED_COMMIT_HASH="$(git log -n1 --format=%H)"

  # Checkout Brew dist-git
  echo "      [${this_name}] Download and Setup Brew dist-git repo"
  cd ${WORKDIR}/brew
  if [ -d ${this_name} ] ; then
    rm -rf ${this_name}
  fi
  rhpkg clone ${this_name} >> ${LOGFILE} 2>&1
  if ! [ $? -eq 0 ] ; then
    echo "      [${this_name}] Unable to clone ${this_name}"
    echo "        [${this_name}] You might not have permissions, or might not be a package."
    end_job ${job_number}
    exit 1
  fi
  cd ${this_name}
  rhpkg switch-branch ${BREW_BRANCH} >> ${LOGFILE} 2>&1
  if ! [ $? -eq 0 ] ; then
    echo "      [${this_name}] Unable to checkout ${this_name} ${BREW_BRANCH}"
    echo "        [${this_name}] Not proceeding further with ${this_name} sync."
    end_job ${job_number}
    exit 1
  fi

  # rsync fed to brew
  echo "      [${this_name}] Syncing from Fed dist-git to Brew dist-git"
  rsync -avH --exclude=.git/ --delete ${WORKDIR}/fed/${this_name}/ ${WORKDIR}/brew/${this_name}/ >> ${LOGFILE} 2>&1
  # autogenerated rpms often have the .spec file and other files in .gitignore, take it out
  #sed -i '/.spec$/d' ${WORKDIR}/brew/${this_name}/.gitignore
  rm -f ${WORKDIR}/brew/${this_name}/.gitignore

  # Push up to brew dist-git
  echo "      [${this_name}] Committing and Uploading to Brew dist-git"
  cd ${WORKDIR}/brew/${this_name}
  if [ -f sources ] ; then
    if grep -q SHA512 sources ; then
      source_list="$(cat sources | awk -F"(" '{print $2}' | awk -F")" '{print $1}' ORS=' ')"
    elif grep -q ^MD5 sources ; then
      source_list="$(cat sources | awk -F"(" '{print $2}' | awk -F")" '{print $1}' ORS=' ')"
    else
      source_list="$(cat sources | awk '{print $2}' ORS=' ')"
    fi
  else
    source_list=""
  fi
  if [ "${VERBOSE}" == "TRUE" ] ; then
    echo "    [${this_name}] source_list: ${source_list}"
    echo "    [${this_name}] COMMIT_MESSAGE: ${COMMIT_MESSAGE}"
  fi
  rhpkg new-sources ${source_list} >> ${LOGFILE} 2>&1
  git add -A >> ${LOGFILE} 2>&1
  rhpkg commit -m "${COMMIT_MESSAGE} fed_hash: ${FED_COMMIT_HASH}" >> ${LOGFILE} 2>&1
  rhpkg push >> ${LOGFILE} 2>&1
  BREW_COMMIT_HASH="$(git log -n1 --format=%H)"

  # Document what hashes matchs
  if [ "${VERBOSE}" == "TRUE" ] ; then
    echo "    [${this_name}] THIS_NVR: ${THIS_NVR}"
    echo "    [${this_name}] FED_COMMIT_HASH: ${FED_COMMIT_HASH}"
    echo "    [${this_name}] BREW_COMMIT_HASH: ${BREW_COMMIT_HASH}"
  fi
  echo "${THIS_NVR} fed_rev: ${FED_COMMIT_HASH} brew_rev: ${BREW_COMMIT_HASH}" >> ${WORKDIR}/map/${this_name}

  echo "    [${this_name}] Syncing End"
  if [ "${job_type}" == "newjob" ] ; then
    end_job ${job_number}
  fi
}

###############
# Build packages
###############
build_package() {
  job_number="${1}"
  this_name="$(echo ${2} | awk '{print $1}')"
  fed_hash="$(echo ${2} | awk '{print $2}')"
  this_nvr="$(echo ${2} | awk '{print $3}')"
  if [ "${fed_hash}" == "" ] ; then
    fed_hash="${FED_GIT_CHECKOUT}"
  fi
  this_brew_check=""
  if [ "${BREW_CHECK}" == "TRUE" ] ; then
    wget -q -O /dev/null ${BREW_DISTGIT_URL}/rpms/${this_name}/log/?h=${BREW_BRANCH}
    if [ $? -gt 0 ] ; then
      this_brew_check="FAILED"
    fi
  fi
  if [ "${this_brew_check}" == "FAILED" ] ; then
    echo "  [${this_name}] BREW DIST-GIT IS NOT SETUP YET"
    echo "${this_name}" >> ${WORKDIR}/logs/request-needed-$(date +%Y-%m-%d)
  else
    echo "  [${this_name}] Build Setup Start"
    if [ -f ${WORKDIR}/map/${this_name} ] ; then
      test_hash="$(tail -n 1 ${WORKDIR}/map/${this_name} | awk '{print $3}')"
    fi
    if [ "${VERBOSE}" == "TRUE" ] ; then
      echo "    NVR: ${this_nvr}"
      echo "    Name: ${this_name}"
      echo "    Fed Hash: ${fed_hash}"
      echo "    Old Hash: ${test_hash}"
    fi
    if [ "${test_hash}" == "${fed_hash}" ] ; then
      echo "    [${this_name}] Already synced from Fedora to Brew dist-git"
    else
      echo "    [${this_name}] Syncing from Fedora to Brew dist-git"
      sync_distgit "oldjob" ${job_number} "${this_name} ${fed_hash}"
    fi
    # Everything should be setup by now, lets start the build
    if [ -f ${WORKDIR}/logs/${this_name}.build ] ; then
      echo "    [${this_name}] Already Building"
    else
      if grep "fednvr:${this_nvr} fedhash:${fed_hash}" ${WORKDIR}/results/${this_name}/status.txt 2>/dev/null | grep -q SUCCESS:  ; then
        echo "    [${this_name}] Already Successfully Built"
      else
        echo "    [${this_name}] Build Needed - Setting up"
        if [ -d ${WORKDIR}/brew/${this_name} ] ; then
          cd ${WORKDIR}/brew/${this_name}
          rhpkg switch-branch ${BREW_BRANCH} >/dev/null 2>&1
          if ! [ $? -eq 0 ] ; then
            echo "    [${this_name}] Unable to checkout ${this_name} ${BREW_BRANCH}"
            echo "      [${this_name}] Not proceeding further with ${this_name} build."
            end_job ${job_number}
            exit 2
          fi
          rhpkg pull >/dev/null 2>&1
        else
          cd ${WORKDIR}/brew
          rhpkg clone ${this_name} >/dev/null 2>&1
          if ! [ $? -eq 0 ] ; then
            echo "    [${this_name}] Unable to clone ${this_name}"
            echo "      [${this_name}] You might not have permissions, or"
            echo "      [${this_name}] ${this_name} might not be a package."
            end_job ${job_number}
            exit 2
          fi
          cd ${WORKDIR}/brew/${this_name}
          rhpkg switch-branch ${BREW_BRANCH} >/dev/null 2>&1
          if ! [ $? -eq 0 ] ; then
            echo "    [${this_name}] Unable to checkout ${this_name} ${BREW_BRANCH}"
            echo "      [${this_name}] Not proceeding further with ${this_name} build."
            end_job ${job_number}
            exit 2
          fi
        fi
        echo "${this_name} fednvr:${this_nvr} fedhash:${fed_hash} " >> ${WORKDIR}/logs/${this_name}.build
        rhpkg build --skip-nvr-check --nowait >> ${WORKDIR}/logs/${this_name}.build 2>&1
      fi
    fi
    echo "  [${this_name}] Build Setup End"
  fi
  end_job ${job_number}
}

###############
# Check build status
###############
check_build_status() {
  job_number="${1}"
  build_log="${2}"
  this_stat_line="$(head -n1 ${build_log})"
  this_name="$(echo ${build_log} | sed 's|.build$||')"
  task_number="$(grep Created ${build_log} | awk '{print $3}')"
  echo "  [${this_name}] Check Start"
  if [ "${task_number}" == "" ] ; then
    echo "    [${this_name}] ERROR: No task_number found"
    this_nvr="ERROR"
    task_number="ERROR"
    this_status="ERROR"
    update_overall_status ${this_name} ${this_status} ${task_number} ${this_nvr}
  else
    this_taskinfo="$(brew taskinfo ${task_number})"
    this_state="$(echo "${this_taskinfo}" | grep State: | awk '{print $2}')"
    this_nvr="$(echo "${this_taskinfo}" | grep Build: | awk '{print $2}')"
    echo "    [${this_name}] Current State: ${this_state}"
    if [ "${this_state}" == "closed" ] || [ "${this_state}" == "failed" ] || [ "${this_state}" == "canceled" ] ; then
      mkdir -vp ${WORKDIR}/results/${this_name}/${task_number} > /dev/null
      if [ "${this_state}" == "closed" ] ; then
        this_status="SUCCESS"
      fi
      if [ "${this_state}" == "failed" ] ; then
        this_status="FAILURE"
        echo "      [${this_name}] Downloading failed build logs."
        brew download-logs -r -d ${WORKDIR}/results/${this_name}/${task_number} ${task_number} > /dev/null 2>&1
      fi
      if [ "${this_state}" == "canceled" ] ; then
        this_status="FAILURE"
      fi
      update_overall_status ${this_name} ${this_status} ${task_number} ${this_nvr}
      this_fed_info="$(echo ${this_stat_line} | awk '{print $2 " " $3}')"
      echo "${this_status}: ${this_nvr} ${BREW_WEB_URL}/taskinfo?taskID=${task_number} ${this_fed_info}" >> ${WORKDIR}/results/${this_name}/status.txt
      mv ${WORKDIR}/logs/${build_log} ${WORKDIR}/results/${this_name}/${task_number}/${build_log}.txt
      rm -rf ${WORKDIR}/brew/${this_name}
    else
      this_status="BUILDING"
      update_overall_status ${this_name} ${this_status} ${task_number} ${this_nvr}
    fi
  fi
  echo "  [${this_name}] Check End"
  end_job ${job_number}
}

###############
# Create Status Web Page
###############
create_status_page() {
  sort -o ${OVERALL_TXT} ${OVERALL_TXT}
  overall_total="$(cat ${OVERALL_TXT} |wc -l)"
  overall_building="$(grep BUILDING ${OVERALL_TXT} |wc -l)"
  overall_success="$(grep SUCCESS ${OVERALL_TXT} |wc -l)"
  overall_failure="$(grep -e FAILURE -e ERROR ${OVERALL_TXT} |wc -l)"

  echo "    Starting Overall web page"
  for this_type in Overall Building Failure
  do
    if [ "${this_type}" == "Overall" ] ; then
      this_html="${OVERALL_HTML}"
    elif [ "${this_type}" == "Building" ] ; then
      this_html="${BUILDING_HTML}"
    else
      this_html="${FAILURE_HTML}"
    fi

    rm -f ${this_html}
    echo "<html>" >> ${this_html}
    echo "<head><title>RHEL Build Progress ${this_type}</title></head>" >> ${this_html}
    echo "<body>" >> ${this_html}
    echo "<h1>RHEL ${this_type} Build Progress: ${BREW_DIST}</h1>" >> ${this_html}
    echo "<p>Page updated: " >> ${this_html}
    date --utc >> ${this_html}
    echo "</p>" >> ${this_html}
    echo "<h2>Module Pages</h2>" >> ${this_html}
    echo "<p>" >> ${this_html}
    for this_mod_name in overall-status ${MODULE_LIST}
    do
      echo " .. <a href=\"${this_mod_name}.html\">${this_mod_name} </a> .. " >> ${this_html}
    done
    echo "</p>" >> ${this_html}
    echo "<h2>Totals</h2>" >> ${this_html}
    echo "<p>" >> ${this_html}
    echo "<a href=\"overall-building-status.html\">Building:</a> <strong>${overall_building}</strong><br>" >> ${this_html}
    echo "<a href=\"overall-status.html\">Success:</a> <strong>${overall_success}</strong><br>" >> ${this_html}
    echo "<a href=\"overall-failure-status.html\">Failure:</a> <strong>${overall_failure}</strong><br>" >> ${this_html}
    echo "Total: <strong>${overall_total}</strong><br>" >> ${this_html}
    echo "</p>" >> ${this_html}
    echo "<h2>Details</h2>" >> ${this_html}
    echo "<table border=1 style="width:100%">" >> ${this_html}
    echo "<tr><th>Name</th><th>STATUS</th><th>NVR</th><th>Build URL</th></tr>" >> ${this_html}
  done

  cat ${OVERALL_TXT} | while read line
  do
    this_name="$(echo ${line} | awk '{print $1}')"
    this_status="$(echo ${line} | awk '{print $2}')"
    this_nvr="$(echo ${line} | awk '{print $3}')"
    task_url="$(echo ${line} | awk '{print $4}')"
    if [ "${task_url}" == "" ] ; then
      task_url="${this_nvr}"
      this_nvr="Still in build setup"
    fi
    task_number="$(echo ${task_url} | awk -F'=' '{print $2}')"
    if [ "${VERBOSE}" == "TRUE" ] ; then
      echo "    this_name: ${this_name}"
      echo "    this_nvr: ${this_nvr}"
      echo "    this_status: ${this_status}"
      echo "    task_number: ${task_number}"
      echo "    task_url: ${task_url}"
    fi
    this_color="#FF0000"
    if [ "${this_status}" == "SUCCESS" ] ; then
          this_color="#00FF00"
    elif [ "${this_status}" == "BUILDING" ] ; then
          this_color="#00FFFF"
    fi
    echo "<tr><td><a href=\"${this_name}/\">${this_name}</a></td><td bgcolor=\"${this_color}\">${this_status}</td><td>${this_nvr}</td><td><a href=\"${task_url}\">${task_number}</a></td></tr>" >> ${OVERALL_HTML}
    if [ "${this_status}" == "BUILDING" ] ; then
      echo "<tr><td><a href=\"${this_name}/\">${this_name}</a></td><td bgcolor=\"${this_color}\">${this_status}</td><td>${this_nvr}</td><td><a href=\"${task_url}\">${task_number}</a></td></tr>" >> ${BUILDING_HTML}
    elif [ "${this_status}" == "FAILURE" ] ; then
      echo "<tr><td><a href=\"${this_name}/\">${this_name}</a></td><td bgcolor=\"${this_color}\">${this_status}</td><td>${this_nvr}</td><td><a href=\"${task_url}\">${task_number}</a></td></tr>" >> ${FAILURE_HTML}
    fi
  done

  for mod_name in ${MODULE_LIST}
  do
    echo "    Starting ${mod_name} web page"
    rm -f ${WEB_DIR}/${mod_name}.html
    echo "<html>" >> ${WEB_DIR}/${mod_name}.html
    echo "<head><title>RHEL Build Progress ${mod_name}</title></head>" >> ${WEB_DIR}/${mod_name}.html
    echo "<body>" >> ${WEB_DIR}/${mod_name}.html
    echo "<h1>RHEL ${mod_name} Build Progress: ${BREW_DIST}</h1>" >> ${WEB_DIR}/${mod_name}.html
    echo "<p>Page updated: " >> ${WEB_DIR}/${mod_name}.html
    date --utc >> ${WEB_DIR}/${mod_name}.html
    echo "</p>" >> ${WEB_DIR}/${mod_name}.html
    echo "<h2>Module Pages</h2>" >> ${WEB_DIR}/${mod_name}.html
    echo "<p>" >> ${WEB_DIR}/${mod_name}.html
    for this_mod_name in overall-status ${MODULE_LIST}
    do
      echo " .. <a href=\"${this_mod_name}.html\">${this_mod_name} </a> .. " >> ${WEB_DIR}/${mod_name}.html
    done
    echo "</p>" >> ${WEB_DIR}/${mod_name}.html
    echo "<h2>Totals</h2>" >> ${WEB_DIR}/${mod_name}.html
    echo "<p>" >> ${WEB_DIR}/${mod_name}.html
    echo "Building: <strong>::BUILD-PLACEHOLDER::</strong><br>" >> ${WEB_DIR}/${mod_name}.html
    echo "Success: <strong>::SUCC-PLACEHOLDER::</strong><br>" >> ${WEB_DIR}/${mod_name}.html
    echo "Failure: <strong>::FAIL-PLACEHOLDER::</strong><br>" >> ${WEB_DIR}/${mod_name}.html
    echo "Unknown: <strong>::UNKNOWN-PLACEHOLDER::</strong><br>" >> ${WEB_DIR}/${mod_name}.html
    echo "Total: <strong>::TOTAL-PLACEHOLDER::</strong><br>" >> ${WEB_DIR}/${mod_name}.html
    echo "</p>" >> ${WEB_DIR}/${mod_name}.html
    echo "<h2>Details</h2>" >> ${WEB_DIR}/${mod_name}.html
    echo "<table border=1 style="width:100%">" >> ${WEB_DIR}/${mod_name}.html
    echo "<tr><th>Name</th><th>STATUS</th><th>NVR</th><th>Build URL</th></tr>" >> ${WEB_DIR}/${mod_name}.html

    cat  ${WEB_DIR}/${mod_name}.txt | while read line
    do
      package_line="$(grep ">${line}<" ${OVERALL_HTML})"
      if [ "${package_line}" == "" ]; then
        package_line="<tr><td>${line}</td><td>NO INFO</td><td>No Info</td><td>No Info</td></tr>"
      fi
      echo "${package_line}" >> ${WEB_DIR}/${mod_name}.html
    done

    echo "</table>" >> ${WEB_DIR}/${mod_name}.html
    echo "</body>" >> ${WEB_DIR}/${mod_name}.html
    echo "</html>" >> ${WEB_DIR}/${mod_name}.html

    mod_total="$(cat ${WEB_DIR}/${mod_name}.txt |wc -l)"
    mod_building="$(grep BUILDING ${WEB_DIR}/${mod_name}.html |wc -l)"
    mod_success="$(grep SUCCESS ${WEB_DIR}/${mod_name}.html |wc -l)"
    mod_failure="$(grep -e FAILURE -e ERROR ${WEB_DIR}/${mod_name}.html |wc -l)"
    mod_unknown="$(grep "NO INFO" ${WEB_DIR}/${mod_name}.html |wc -l)"
    sed -i "s/::TOTAL-PLACEHOLDER::/${mod_total}/" ${WEB_DIR}/${mod_name}.html
    sed -i "s/::BUILD-PLACEHOLDER::/${mod_building}/" ${WEB_DIR}/${mod_name}.html
    sed -i "s/::SUCC-PLACEHOLDER::/${mod_success}/" ${WEB_DIR}/${mod_name}.html
    sed -i "s/::FAIL-PLACEHOLDER::/${mod_failure}/" ${WEB_DIR}/${mod_name}.html
    sed -i "s/::UNKNOWN-PLACEHOLDER::/${mod_unknown}/" ${WEB_DIR}/${mod_name}.html

  done

  for this_html in ${OVERALL_HTML} ${BUILDING_HTML} ${FAILURE_HTML}
  do
    echo "</table>" >> ${this_html}
    echo "</body>" >> ${this_html}
    echo "</html>" >> ${this_html}
  done
}

###############
# Start a job
###############
start_job() {
  if [ -s ${JOB_TRACKER} ] ; then
    HAVE_JOB="TRUE"
  else
    HAVE_JOB="FALSE"
  fi
  while [ "${HAVE_JOB}" == "FALSE" ]
  do
    sleep 5
    if [ -s ${JOB_TRACKER} ] ; then
      HAVE_JOB="TRUE"
    fi
  done
  job_number=$(flock ${JOB_TRACKER} -c "head -n 1 ${JOB_TRACKER} | cut -d':' -f2 ; sed -i '1d' ${JOB_TRACKER}")
  echo "${job_number}"
}

###############
# End a job
###############
end_job() {
  if [ "${VERBOSE}" == "TRUE" ] ; then
    echo "JOB ENDING: ${1}"
  fi
  flock ${JOB_TRACKER} echo ":${1}:" >> ${JOB_TRACKER}
}

###############
# Wait for all jobs to finish
###############
wait_for_jobs() {
  job_queue_size="$(cat ${JOB_TRACKER} | wc -l )"
  while [ ${job_queue_size} -lt ${PARALLEL_JOBS} ]
  do
    # echo "WAITING FOR JOBS TO FINISH: ${job_queue_size} / ${PARALLEL_JOBS}"
    sleep 10
    job_queue_size="$(cat ${JOB_TRACKER} | wc -l )"
  done
}

###############
# Get our arguments
###############
while [[ "$#" -ge 1 ]]
do
key="$1"
case $key in
    --sync )
      export COMMAND="SYNC"
    ;;
    --check )
      export COMMAND="CHECK"
    ;;
    --build | --rebuild )
      export COMMAND="BUILD"
    ;;
    -c | --checkout )
      export FED_GIT_CHECKOUT="${2}"
      shift
    ;;
    -bb | --brew-branch )
      export BREW_BRANCH="${2}"
      shift
    ;;
    -fd | --fed-dist )
      export FED_DIST="${2}"
      shift
    ;;
    -bd | --brew-dist )
      export BREW_DIST="${2}"
      shift
    ;;
    -m | --message )
      export CUSTOM_MESSAGE="${2}"
      shift
    ;;
    --yaml )
      export YAML_FILE="${2}"
      shift
    ;;
    --jobs )
      export PARALLEL_JOBS="${2}"
      shift
    ;;
    --text )
      export TEXT_FILE="${2}"
      shift
    ;;
    --no-remote | --noremote)
      export REMOTE="FALSE"
    ;;
    --brew-check | --brewcheck )
      export BREW_CHECK="TRUE"
    ;;
    -v | --verbose | --debug)
      export VERBOSE="TRUE"
    ;;
    -h | --help )
      usage
      exit 1
    ;;
    *)
      PACKAGE_LIST="${PACKAGE_LIST} ${key}"
    ;;
esac
shift # past argument or value
done

if [ "${SYNC_REMOTE}" == "" ] ; then
  export REMOTE="FALSE"
fi

###############
# parallel job setup
###############
rm -f ${JOB_TRACKER}
for ((i=1; i <= ${PARALLEL_JOBS} ; i++))
do
  echo ":${i}:" >> ${JOB_TRACKER}
done

if [ "${VERBOSE}" == "TRUE" ] ; then
  echo "COMMAND: ${COMMAND}"
  echo "WORKDIR: ${WORKDIR}"
  echo "OVERALL_TXT: ${OVERALL_TXT}"
  echo "OVERALL_HTML: ${OVERALL_HTML}"
  echo "FED_GIT_CHECKOUT: ${FED_GIT_CHECKOUT}"
  echo "FED_DIST: ${FED_DIST}"
  echo "BREW_BRANCH: ${BREW_BRANCH}"
  echo "BREW_DIST: ${BREW_DIST}"
  echo "BREW_CHECK: ${BREW_CHECK}"
  echo "PACKAGE_LIST: ${PACKAGE_LIST}"
  echo "CUSTOM_MESSAGE: ${CUSTOM_MESSAGE}"
  echo "LOGFILE: ${LOGFILE}"
  echo "YAML_FILE: ${YAML_FILE}"
  echo "TEXT_FILE: ${TEXT_FILE}"
  echo "REMOTE: ${REMOTE}"
  echo "SYNC_REMOTE: ${SYNC_REMOTE}"
  echo "PARALLEL_JOBS: ${PARALLEL_JOBS}"
fi

case "${COMMAND}" in
  SYNC )
    if [ "${BREW_BRANCH}" == "" ] ; then
      echo ; echo "ERROR: No brew branch given" ; echo
      usage
      exit 3
    fi
    if [ "${YAML_FILE}" == "" ] && [ "${TEXT_FILE}" == "" ] && [ "${PACKAGE_LIST}" == "" ]; then
      echo ; echo "ERROR: No packages or files given to process" ; echo
      usage
      exit 5
    fi
    if [ "${REMOTE}" == "TRUE" ] ; then
      echo "Syncing mapping from remote area"
      rsync_in map
    fi
    echo "Gathering package information"
    get_packages | while read line
    do
      this_job=$(start_job)
      if [ "${VERBOSE}" == "TRUE" ] ; then
        echo "JOB STARTING: ${this_job} LINE: ${line}"
      fi
      sync_distgit "newjob" ${this_job} "${line}" &
    done
    wait_for_jobs
    if [ "${REMOTE}" == "TRUE" ] ; then
      echo "Syncing mapping to remote area"
      rsync_out map
    fi
  ;;
  CHECK )
    if [ "${REMOTE}" == "TRUE" ] ; then
      echo "  RSYNC FROM  REMOTE"
      rsync_in results
    fi
    echo "  START STATUS CHECK"
    cd ${WORKDIR}/logs
    build_list="$(ls -1 *.build 2>/dev/null)"
    if [ "${build_list}" == "" ] ; then
      echo "    No builds to process"
    else
      for build_log in ${build_list}
      do
        this_job=$(start_job)
        if [ "${VERBOSE}" == "TRUE" ] ; then
          echo "JOB STARTING: ${this_job} LOG: ${build_log}"
        fi
        check_build_status  ${this_job} ${build_log} &
      done
    fi
    wait_for_jobs
    echo "  END STATUS CHECK"
    echo "  START STATUS WEB PAGE CREATION"
    create_status_page
    echo "  END STATUS WEB PAGE CREATION"
    if [ "${REMOTE}" == "TRUE" ] ; then
      echo "  RSYNC TO  REMOTE"
      rsync_out results
    fi
  ;;
  BUILD )
    if [ "${BREW_BRANCH}" == "" ] || [ "${BREW_DIST}" == "" ] ; then
      echo ; echo "ERROR: No brew branch and/or brew dist given" ; echo
      usage
      exit 3
    fi
    if [ "${YAML_FILE}" == "" ] && [ "${TEXT_FILE}" == "" ] && [ "${PACKAGE_LIST}" == "" ]; then
      echo ; echo "ERROR: No packages or files given to process" ; echo
      usage
      exit 5
    fi
    if [ "${REMOTE}" == "TRUE" ] ; then
      echo "Syncing mapping from remote area"
      rsync_in map
    fi
    echo "Gathering package information"
    get_packages | while read line
    do
      this_job=$(start_job)
      if [ "${VERBOSE}" == "TRUE" ] ; then
        echo "JOB STARTING: ${this_job} LINE: ${line}"
      fi
      build_package ${this_job} "${line}" &
    done
    wait_for_jobs
    if [ "${REMOTE}" == "TRUE" ] ; then
      echo "Syncing mapping to remote area"
      rsync_out map
    fi
  ;;
  * )
    echo ; echo "ERROR: A command must be given" ; echo
    usage
    exit 4
  ;;
esac

###############
# CLEANUP
###############
rm -f ${JOB_TRACKER} ${LOCK_FILE}

echo "Finished"
exit 0
